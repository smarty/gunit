// Package gunit provides "testing" package hooks and convenience
// functions for writing tests in an xUnit style.
// NOTE: Only some of the exported names in this package
// are meant to be referenced by users of this package:
//
// - Fixture // (as an embedded field on your xUnit-style struct)
// - Fixture.So(...) // (as a convenient assertion method: So(expected, should.Equal, actual))
// - Fixture.Error(...) // (works just like *testing.T.Error(...))
// - Fixture.Errorf(...) // (works just like *testing.T.Errorf(...))
//
// The rest are called from code generated by the command at
// github.com/smartystreets/gunit/gunit.
// Please see the README file and the examples folder for examples.
package gunit

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"runtime"
	"strings"
	"testing"

	"github.com/smartystreets/assertions"
	"github.com/smartystreets/gunit/gunit/generate"
)

// TT represents the functional subset from *testing.T needed by Fixture.
type TT interface {
	Fail()
	Failed() bool
	SkipNow()
}

// Fixture keeps track of test status (failed, passed, skipped) and
// handles custom logging for xUnit style tests as an embedded field.
type Fixture struct {
	t       TT
	log     *bytes.Buffer
	skipped bool
}

// NewFixture is called by generated code.
func NewFixture(t TT) *Fixture {
	return &Fixture{t: t, log: &bytes.Buffer{}}
}

// So is a convenience method for reporting assertion failure messages,
// say from the assertion functions found in github.com/smartystreets/assertions/should.
// Example: self.So(actual, should.Equal, expected)
func (self *Fixture) So(actual interface{}, assert func(actual interface{}, expected ...interface{}) string, expected ...interface{}) {
	if ok, failure := assertions.So(actual, assert, expected...); !ok {
		self.t.Fail()
		self.reportFailure(failure)
	}
}

func (self *Fixture) Error(args ...interface{}) {
	self.t.Fail()
	self.reportFailure(fmt.Sprint(args...))
}

func (self *Fixture) Errorf(format string, args ...interface{}) {
	self.t.Fail()
	self.reportFailure(fmt.Sprintf(format, args...))
}

func (self *Fixture) reportFailure(failure string) {
	_, file, line, _ := runtime.Caller(2) // 0: reportFailre + 1: Error/Errorf/So + 2: func Test...
	self.log.WriteString(fmt.Sprintf("\tX FAILED: %s:%d\n", file, line))
	fmt.Fprint(self.log, "\t\t"+strings.Replace(failure, "\n", "\n\t\t", -1)+"\n")
}

// Describe is called by generated code.
func (self *Fixture) Describe(test string) {
	fmt.Fprintln(self.log, "\t- "+test)
}

// Skip is called by generated code.
func (self *Fixture) Skip(message string) {
	fmt.Fprintln(self.log, "\t? "+message)
	self.skipped = true
}

// Finalize is called by generated code.
func (self *Fixture) Finalize() {
	if verbose() || self.t.Failed() {
		io.WriteString(out, strings.TrimRight(self.log.String(), "\t"))
	}

	if r := recover(); r != nil { // TODO: unit test
		panic(r)
	}

	if self.skipped {
		self.t.SkipNow()
	}
}

//////////////////////////////////////////////////////////////////////////////

// Validate is called by generated code.
func Validate(checksum string) {
	_, file, _, ok := runtime.Caller(1)
	if !ok {
		exit("Unable to resolve the test file from runtime.Caller(...).\n")
	}
	current, err := generate.Checksum(filepath.Dir(file))
	if err != nil {
		exit("Could not calculate checksum of current go files. Error: %s\n", err.Error())
	}
	if checksum != current {
		exit("The checksum provided [%s] does not match the current file listing [%s]. Please re-run the `gunit` command and try again.\n", checksum, current)
	}
}

func exit(message string, args ...interface{}) {
	fmt.Fprintf(os.Stderr, message, args...)
	os.Exit(1)
}

var verbose = testing.Verbose
var out io.Writer = os.Stdout
